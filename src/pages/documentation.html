<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../website/css/documentation.css" />
    <title>Recoilens Recoil Logger Library - RRLL</title>
  </head>

  <body>
    <h1>Documentation</h1>

    <p>
      The Recoilens Recoil Logger Library (RRLL) is a powerful tool designed to
      enhance your experience with Recoil, a state management library for React.
      RRLL provides a custom state logger that allows you to track changes in
      specific atoms and present informative messages as popups, facilitating
      easier debugging and state monitoring in your React applications.
    </p>

    <h2>Installation</h2>

    <p>
      To integrate RRLL into your project, you can utilize npm or yarn, two
      popular package managers for JavaScript:
    </p>

    <pre><code class="language-bash">npm install recoilens
# or
yarn add recoilens</code></pre>

    <h2>Why Choose RRLL?</h2>

    <p>
      RRLL offers a range of benefits that can significantly improve your
      development workflow:
    </p>

    <ul>
      <li>
        <strong>Streamlined Debugging</strong>: Easily track and visualize state
        changes within your Recoil application, making it simpler to identify
        and rectify issues.
      </li>
      <li>
        <strong>Enhanced Visibility</strong>: RRLL provides a clear, concise
        view of state mutations, allowing for a better understanding of how your
        application's state evolves over time.
      </li>
      <li>
        <strong>Improved Collaboration</strong>: Share insights with your team
        by displaying relevant messages whenever state changes occur, enabling
        better communication and collaboration.
      </li>
      <li>
        <strong>Reduced Development Time</strong>: Quickly identify and resolve
        state-related bugs, saving valuable development time.
      </li>
    </ul>

    <h2>Usage</h2>

    <h3>1. Import the Library</h3>

    <pre><code class="language-jsx">import RecoilLogger from "recoilens";</code></pre>

    <h3>2. Wrap your Application in <code>RecoilRoot</code></h3>

    <pre><code class="language-jsx">import { RecoilRoot } from "recoil";

const App = () => {
  return (
    &lt;RecoilRoot&gt;
      &lt;RecoilLogger value={myAtom} /&gt;
      {/* Other components */}
    &lt;/RecoilRoot&gt;
  );
};

export default App;</code></pre>

    <h3>3. Define Atoms and Controls</h3>

    <pre><code class="language-jsx">import { useRecoilState, atom } from "recoil";

export const myAtom = atom({
  key: "myAtom",
  default: {
    property: 0,
  },
});

const ButtonControls = () => {
  const [currentValue, setCurrentValue] = useRecoilState(myAtom);

  const increaseValue = () => {
    setCurrentValue((prevValue) => {
      const updatedValue = {
        ...prevValue,
        property: prevValue.property + 1,
      };
      return updatedValue;
    });
  };

  const decreaseValue = () => {
    setCurrentValue((prevValue) => {
      const updatedValue = {
        ...prevValue,
        property: prevValue.property - 1,
      };
      return updatedValue;
    });
  };

  return (
    &lt;div&gt;
      &lt;button onClick={increaseValue}&gt;Increase Value&lt;/button&gt;
      &lt;button onClick={decreaseValue}&gt;Decrease Value&lt;/button&gt;
      &lt;div&gt;Current Value: {currentValue}&lt;/div&gt;
    &lt;/div&gt;
  );
};</code></pre>

    <h3>4. Run Your Application</h3>

    <p>
      Start your application to witness the Recoilens Logger in action,
      providing real-time feedback on state changes.
    </p>

    <h2>Tips and Best Practices</h2>

    <ul>
      <li>
        <strong>Modularize Atoms</strong>: Break down complex atoms into
        smaller, modular pieces. This promotes code reusability and makes it
        easier to reason about your application's state.
      </li>
      <li>
        <strong>Avoid Over-Nesting Components</strong>: While it's important to
        structure your application, avoid excessive nesting of components. This
        can lead to unnecessary complexity and hinder debugging efforts.
      </li>
      <li>
        <strong>Throttle or Debounce Updates</strong>: Consider using throttling
        or debouncing techniques for frequent state updates. This can help
        reduce unnecessary re-rendering and improve performance.
      </li>
      <li>
        <strong>Use Selectors for Derived State</strong>: When dealing with
        derived state, utilize Recoil selectors. They provide an efficient way
        to compute values based on the current state.
      </li>
      <li>
        <strong>Leverage Atom Family and Recoil Units</strong>: For managing
        multiple similar pieces of state, consider using atom families and
        Recoil units. These can help reduce boilerplate code and enhance
        maintainability.
      </li>
      <li>
        <strong>Write Unit Tests</strong>: Test your Recoil state management
        logic to ensure it behaves as expected. Utilize testing libraries like
        Jest and React Testing Library for comprehensive coverage.
      </li>
      <li>
        <strong>Monitor Performance</strong>: Keep an eye on the performance of
        your Recoil-enabled components. Utilize browser developer tools and
        performance profiling to identify potential bottlenecks.
      </li>
    </ul>

    <h2>Troubleshooting and FAQs</h2>

    <h3>Q: Why is my component not re-rendering after a state change?</h3>

    <p>
      A: Check if you're using <code>useRecoilState</code> or
      <code>useRecoilValue</code> hooks correctly. Make sure you're accessing
      the atom in a component that is within the
      <code>RecoilRoot</code> context.
    </p>

    <h3>Q: How can I handle asynchronous state updates?</h3>

    <p>
      A: Recoil supports asynchronous state updates through
      <code>useRecoilCallback</code> or by using selectors with async functions.
      Ensure you're managing async operations appropriately and handling any
      potential race conditions.
    </p>

    <h3>Q: Can I use RRLL with other state management libraries?</h3>

    <p>
      A: RRLL is specifically designed for use with Recoil. While it may be
      possible to integrate with other libraries, it's recommended to follow
      Recoil's conventions for optimal compatibility and performance.
    </p>

    <h3>
      Q: My application is throwing an error related to circular dependencies.
      What should I do?
    </h3>

    <p>
      A: Circular dependencies can occur if you have atoms that depend on each
      other in a loop. Refactor your state structure to eliminate the circular
      dependency, or consider using selectors to compute derived state.
    </p>

    <h3>
      Q: How can I optimize performance when dealing with large amounts of
      state?
    </h3>

    <p>
      A: Consider using selectors to compute derived state only when necessary.
      Additionally, utilize Recoil's built-in optimizations and consider
      splitting large atoms into smaller, more manageable pieces.
    </p>

    <h3>Q: Is RRLL suitable for production use?</h3>

    <p>
      A: RRLL is designed to enhance the development experience with Recoil.
      It's important to thoroughly test and validate your application with RRLL
      in a production-like environment before deploying it to production.
    </p>

    <h2>License</h2>

    <p>This library is released under the MIT License.</p>
  </body>
</html>
